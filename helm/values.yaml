namespace: memmachine
backend:
  enabled: true
  name: backend
  image:
    repository: memmachine/memmachine
    tag: v0.1.1-cpu
    pullPolicy: IfNotPresent
  replicaCount: 1
  service:
    type: ClusterIP
    port: 8080
  resources:
    requests:
      cpu: 2
      memory: 2Gi
    limits:
      cpu: 2
      memory: 2Gi
      #nvidia.com/gpu: 1
  env: [] 
  config:
    file: "configuration.yml"
    openai_api_key: "sk-OPENAI_API_KEY"
    testmodel:
      vendor: openai
      name: gpt-4o-mini
    sessionMemory:
      model_name: testmodel
      message_capacity: 500
      max_message_length: 16000
      max_token_num: 8000
    embedder:
      model_name: "text-embedding-3-small"
  nodeSelector: {}
  tolerations: []
  affinity: {}

neo4j:
  enabled: true
  # REQUIRED: a unique Neo4j cluster/instance name within the namespace
  neo4j:
    name: neo4j
    user: neo4j
    # Community by default; set to "enterprise" + accept license to use EE
    edition: "community"   # or "enterprise"
    # You cannot use "neo4j" as the initial password. Leave empty to auto-generate.  [oai_citation:1‡Graph Database & Analytics](https://neo4j.com/docs/operations-manual/current/kubernetes/quickstart-standalone/create-value-file)
    password: "changeMeS3cure"
    # For Enterprise, set one of: "yes" (licensed) or "eval" (evaluation).  [oai_citation:2‡Graph Database & Analytics](https://neo4j.com/docs/operations-manual/current/kubernetes/quickstart-standalone/create-value-file)
    acceptLicenseAgreement: "no"
  
  # Resources (tune to your cluster)
  resources:
    cpu: "2"
    memory: "4Gi"
    limits:
      cpu: "4"
      memory: "6Gi"
    requests:
      cpu: "4"
      memory: "6Gi"
  # Example: enable useful config via neo4j.conf settings
  # NOTE: All neo4j.conf values must be strings.  [oai_citation:3‡Graph Database & Analytics](https://neo4j.com/docs/operations-manual/current/kubernetes/configuration)
  config:
    server.metrics.enabled: "true"
    dbms.security.auth_enabled: "true"
    server.config.strict_validation.enabled: "false"
    server.memory.heap.initial_size: "1G"
    server.memory.heap.max_size: "1G"
    server.memory.pagecache.size: "1G"

  # (Optional) JVM flags
  jvm:
    additionalJvmArguments:
      - "-XX:+HeapDumpOnOutOfMemoryError"

  # (Optional) install plugins (Neo4j 5 uses NEO4J_PLUGINS)
  env:
    NEO4J_PLUGINS: '["apoc","graph-data-science"]'  # adjust as needed  [oai_citation:4‡Graph Database & Analytics](https://neo4j.com/docs/operations-manual/current/docker/plugins)
  ingress:
    enabled: true
    hostname: neo4j.example.com

  # Storage: default StorageClass via volume claim templates
  volumes:
    data:
      mode: defaultStorageClass  # PVC with default SC. Adjust to match your cluster.  [oai_citation:5‡Graph Database & Analytics](https://neo4j.com/docs/operations-manual/current/kubernetes/quickstart-cluster/create-value-file)
    # To use a specific StorageClass:
    # data:
    #   mode: dynamic
    #   dynamic:
    #     storageClassName: fast-ssd
    #     requests:
    #       storage: 50Gi

  

  # Service exposure (ClusterIP by default)
  service:
    type: ClusterIP

  # If you want browser/Bolt through Ingress, Neo4j recommends a separate reverse-proxy chart.
  # See docs: neo4j/neo4j-reverse-proxy.  [oai_citation:6‡Graph Database & Analytics](https://neo4j.com/docs/operations-manual/current/kubernetes/accessing-neo4j-ingress)
pgvector:
  enabled: true
  image:
    repository: pgvector/pgvector
    tag: pg16
    pullPolicy: IfNotPresent

  replicaCount: 1  # single-instance Postgres (no HA)

  service:
    type: ClusterIP
    port: 5432

  postgres:
    user: memmachine
    # If you set existingSecret, this is ignored. Otherwise a Secret is created with this password:
    password: memmachine_password
    database: postgres  # bootstrap DB used by entrypoint
    existingSecret: ""  # set to name of an existing secret with key POSTGRES_PASSWORD
    initdbArgs: "--encoding=UTF-8 --lc-collate=C --lc-ctype=C"

  databases:
    # List of DBs to create + enable pgvector in (on first boot only)
    profile: tianya_profile
    memzero: tianya_memzero
  
  persistence:
    enabled: true
    storageClass: "local-path"   # leave empty for default, or set to your class
    accessModes:
      - ReadWriteOnce
    size: 10Gi

  resources: {}
  #  limits:
  #    cpu: 500m
  #    memory: 1Gi
  #  requests:
  #    cpu: 250m
  #    memory: 512Mi
  healthcheck:
    enabled: true
    interval: 10s
    timeout: 5s
    retries: 5
    startPeriod: 30s
  podSecurityContext:
    fsGroup: 999      # postgres (Debian-based)
    fsGroupChangePolicy: OnRootMismatch

  securityContext:
    runAsUser: 999
    runAsGroup: 999
    runAsNonRoot: true
    allowPrivilegeEscalation: false
    capabilities:
      drop: ["ALL"]

  nodeSelector: {}
  tolerations: []
  affinity: {}

  annotations: {}
  labels: {}

  livenessProbe:
    enabled: true
    initialDelaySeconds: 20
    periodSeconds: 10
    failureThreshold: 6

  readinessProbe:
    enabled: true
    initialDelaySeconds: 10
    periodSeconds: 5
    failureThreshold: 6

  # Extra env vars to inject into the postgres container
  extraEnv: []
  #  - name: PGDATA
